\documentclass[journal]{IEEEtran}

% Paquetes de idioma y codificación
\usepackage[spanish,es-tabla]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{xcolor}
\lstset{
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  showstringspaces=false,
  breaklines=true
}
% Otros paquetes que ya tenías
\usepackage[pdftex]{graphicx}
\usepackage{color}
\usepackage{cite} % este es el correcto para estilo IEEE
\usepackage{array}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{url}

\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Problema De Las N-Reinas}
\author{	Camilo Campos González, 
        	Ignacia Rodríguez Luengo
        	y Francisco Muñoz Inostroza
\thanks{Camilo Campos González, 
        	Ignacia Rodríguez Luengo
        	y Francisco Muñoz Inostroza son estudiantes de la carrera de Ingeniería Civil Informática del Departamento de Ingeniería Informática, Facultad de Ingeniería, Universidad Católica de la Santísima Concepción, Concepción, Chile. Email: \{ccamposg,irodriguezl,fmunozi\}@ing.ucsc.cl.}
\thanks{Manuscrito recibido el 23 de Agosto de 2025.}}

\markboth{Revista de Algoritmos Metaheurísticos Inspirados en la Naturaleza,~Vol.~22, No.~1, Agosto ~2025}
{Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for Journals}

\maketitle

\begin{abstract} \label{sec:resumen}
El ͏reto de͏ las N-Reinas es ͏un problema básico en o͏ptimización y se ha tra͏tado con varios métodos metaheurísticos. En este trabajo, se hace una revisión que compa͏ra dos formas de usar algoritmos genéticos para solu͏cionar este reto: una con listas p͏rop͏ias de Python y otra mejorad͏a con la biblioteca NumPy. Se midieron las dos maneras viendo tiemp͏o de e͏jecución y éxito en di͏ferentes tablero͏s. L͏os númer͏os dejan v͏er que, aun͏que las dos a͏yudan a ͏encontrar solu͏ciones buenas, la man͏era de usar NumPy da venta͏jas grande͏s al tratar problemas grandes. La fo͏rma con listas fue mej͏or en retos pequeños ya qu͏e ten͏ía menos carga al pri͏nci͏pio.

\end{abstract}

\section{Introducción}
\IEEEPARstart
El problema de las $N$-Reinas es un reto computacional clave que ha funcionado como espacio de prueba para muchas ideas de inteligencia artificial y mejoramiento combinatorio~\cite{bezzel1848}. Desde su creación en el siglo XIX este problema ha sido enfrentado de diferentes maneras, incluso \textit{backtracking}, búsqueda cercana y, más recientemente, métodos metaheurísticos inspirados en procesos naturales~\cite{talbi2009}.  

Los algoritmos genéticos (AG), presentados por Holland en los años setenta~\cite{holland1975}, han mostrado ser muy útiles para solucionar problemas difíciles como el de las $N$-Reinas. Pero, la velocidad de estas implementaciones puede cambiar mucho según cómo se organizan los datos y las herramientas usadas~\cite{shukla2012}.  

Python se ha vuelto muy popular para hacer pruebas rápidas en la ciencia porque su manera de escribir es simple, con sintaxis clara y con muchas bibliotecas útiles~\cite{hunter2007}. Sin embargo, su forma interpretada puede causar alta carga computacional en procesos pesados. \texttt{NumPy}, una herramienta clave para el cálculo científico en Python, soluciona este problema con operaciones vectorizadas y estructuras de datos afinadas~\cite{harris2020}.  

Este trabajo hace algo doble: primero, muestra dos formas completas de hacer algoritmos genéticos para el problema de las $N$-Reinas; segundo, da un análisis que mira las cosas buenas y malas de cada manera en cuanto a cómo funciona, cuánto espacio usa y qué tan bien resuelve el problema.



\section{Método} \label{sec:método}
El problema se trata de poner varias reinas en un tablero grande, pero sin que se amenacen entre ellas. En concreto, en uno cuadrado de $N \times N$ casillas, hay que poner $N$ reinas para que no estén en la misma fila, columna o diagonal \cite{dijkstra1959note}.  
La complejidad crece factorialmente con $N$, haciendo inviable la fuerza bruta para valores más altos de $N$ \cite{moon1999genetic}.  

Los algoritmos genéticos son un tipo de técnica que trata de encontrar soluciones buenas siguiendo la forma en que las cosas cambian en la naturaleza; tienen un grupo de soluciones posibles que cambian por medio de selección, cruce y mutación \cite{goldberg1989genetic}. La aptitud (fitness) de cada persona dice cuán probable es que se reproduzcan, llevando al grupo hacia soluciones mejores.  

Ambas formas usan la representación común para el problema de $N$-Reinas: un conjunto de $N$ números donde el lugar $i$-ésimo muestra qué columna tiene la reina en la fila $i$ \cite{takefuji1991artificial}. Esta forma evita que haya dos reinas junto en una misma fila.  

\textbf{Forma con listas:} usa listas originales de Python para mostrar individuos y cantidades. 

\textbf{Forma con NumPy:} usa arreglos de NumPy para optimizar el almacenamiento y operaciones de números.  


Ambas implementaciones usan la misma función de fitness que mide los choques entre reinas:

\begin{lstlisting}[language=Python, caption={Función de fitness para el problema de las $N$-Reinas}]
def fitness(tablero, n):
    acum = 0
    size = len(tablero)
    columna_i = 0
    for i in tablero:
        for j in range(columna_i + 1, size):
            if i == tablero[j]:  # Conflicto en columna
                acum = acum + 1
            # Conflicto en diagonal
            if int(tablero[j]) + (j - columna_i) == int(i) or int(tablero[j]) - (j - columna_i) == int(i):
                acum = acum + 1
        columna_i = columna_i + 1
    return (n * (n - 1) / 2) - acum
\end{lstlisting}

Ambas implementaciones utilizan los mismos operadores genéticos para poder compararlos.  
\begin{itemize}
    \item \textbf{Selección:} Método de ruleta con manejo de caso especial cuando todos los individuos tienen fitness cero.
    \item \textbf{Cruce:} Cruzamiento en un punto (\textit{single-point crossover}).
    \item \textbf{Mutación:} Intercambio de dos posiciones aleatorias con probabilidad configurable.
\end{itemize}

La principal diferencia radica en la inicialización de la población:

\textbf{Con listas:}

\begin{lstlisting}[language=Python, caption={Inicialización de la población usando listas}]
def inicializar_poblacion(tamaño_poblacion, n):
    poblacion = []
    for i in range(tamaño_poblacion):
        aux = " "
        for j in range(n):
            aux = str(aux) + str(generar_entero_aleatorio(n)) + " "
        poblacion.append(list(aux.split()))
    return poblacion
\end{lstlisting}

\textbf{Con NumPy:}

\begin{lstlisting}[language=Python, caption={Inicialización de la población usando NumPy}]
import numpy as np

def inicializar_poblacion(tamaño_poblacion, n):
    poblacion_array = np.random.randint(1, n + 1, size=(tamaño_poblacion, n), dtype=np.int8)
    poblacion = []
    for i in range(tamaño_poblacion):
        poblacion.append(poblacion_array[i])
    return poblacion
\end{lstlisting}

\section{Aplicaciones} \label{sec:aplicaciones}
En esta sección se muestra el \textit{estado del arte} de las aplicaciones que se han resuelto con la metodología estudiada, es decir, donde se indica lo último, más avanzado, tecnología de punta o al límite de conocimiento humano público sobre la metodología de estudio. Cada aplicación expuesta en el informe debe ir con su respectiva referencia bibliográfica que evidencia que la aplicación del algoritmo de estudio se aplicó a una problemática en particular.

Finalmente, en esta sección se debe explicar del manera breve y concisa uno de ellos identificando algunos o todos los elementos vistos en la Sección~\ref{sec:método}.


\section{Conclusiones} \label{sec:conclusiones}
En las conclusiones se  debe de realizar un resumen del trabajo realizado en donde se indique los ventajas y desventajas del algoritmo estudiado y cual fue la contribución o aporte del trabajo desarrollado.


\bibliographystyle{IEEEtran}
\bibliography{referencias}
\end{document}
